/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.177.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// PolicyViolationsAPIService PolicyViolationsAPI service
type PolicyViolationsAPIService service

type ApiGetApplicableWaiversRequest struct {
	ctx context.Context
	ApiService *PolicyViolationsAPIService
	violationId string
}

func (r ApiGetApplicableWaiversRequest) Execute() (*ApiPolicyWaiversApplicableToViolationDTO, *http.Response, error) {
	return r.ApiService.GetApplicableWaiversExecute(r)
}

/*
GetApplicableWaivers Method for GetApplicableWaivers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param violationId
 @return ApiGetApplicableWaiversRequest
*/
func (a *PolicyViolationsAPIService) GetApplicableWaivers(ctx context.Context, violationId string) ApiGetApplicableWaiversRequest {
	return ApiGetApplicableWaiversRequest{
		ApiService: a,
		ctx: ctx,
		violationId: violationId,
	}
}

// Execute executes the request
//  @return ApiPolicyWaiversApplicableToViolationDTO
func (a *PolicyViolationsAPIService) GetApplicableWaiversExecute(r ApiGetApplicableWaiversRequest) (*ApiPolicyWaiversApplicableToViolationDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiPolicyWaiversApplicableToViolationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationsAPIService.GetApplicableWaivers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/{violationId}/applicableWaivers"
	localVarPath = strings.Replace(localVarPath, "{"+"violationId"+"}", url.PathEscape(parameterValueToString(r.violationId, "violationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiPolicyWaiversApplicableToViolationDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCrossStagePolicyViolationByConstituentIdRequest struct {
	ctx context.Context
	ApiService *PolicyViolationsAPIService
	constituentId *string
}

func (r ApiGetCrossStagePolicyViolationByConstituentIdRequest) ConstituentId(constituentId string) ApiGetCrossStagePolicyViolationByConstituentIdRequest {
	r.constituentId = &constituentId
	return r
}

func (r ApiGetCrossStagePolicyViolationByConstituentIdRequest) Execute() (*ApiCrossStageViolationDTOV2, *http.Response, error) {
	return r.ApiService.GetCrossStagePolicyViolationByConstituentIdExecute(r)
}

/*
GetCrossStagePolicyViolationByConstituentId Method for GetCrossStagePolicyViolationByConstituentId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCrossStagePolicyViolationByConstituentIdRequest
*/
func (a *PolicyViolationsAPIService) GetCrossStagePolicyViolationByConstituentId(ctx context.Context) ApiGetCrossStagePolicyViolationByConstituentIdRequest {
	return ApiGetCrossStagePolicyViolationByConstituentIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiCrossStageViolationDTOV2
func (a *PolicyViolationsAPIService) GetCrossStagePolicyViolationByConstituentIdExecute(r ApiGetCrossStagePolicyViolationByConstituentIdRequest) (*ApiCrossStageViolationDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiCrossStageViolationDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationsAPIService.GetCrossStagePolicyViolationByConstituentId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/crossStage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.constituentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constituentId", r.constituentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiCrossStageViolationDTOV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCrossStagePolicyViolationByIdRequest struct {
	ctx context.Context
	ApiService *PolicyViolationsAPIService
	violationId string
}

func (r ApiGetCrossStagePolicyViolationByIdRequest) Execute() (*ApiCrossStageViolationDTOV2, *http.Response, error) {
	return r.ApiService.GetCrossStagePolicyViolationByIdExecute(r)
}

/*
GetCrossStagePolicyViolationById Method for GetCrossStagePolicyViolationById

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param violationId
 @return ApiGetCrossStagePolicyViolationByIdRequest
*/
func (a *PolicyViolationsAPIService) GetCrossStagePolicyViolationById(ctx context.Context, violationId string) ApiGetCrossStagePolicyViolationByIdRequest {
	return ApiGetCrossStagePolicyViolationByIdRequest{
		ApiService: a,
		ctx: ctx,
		violationId: violationId,
	}
}

// Execute executes the request
//  @return ApiCrossStageViolationDTOV2
func (a *PolicyViolationsAPIService) GetCrossStagePolicyViolationByIdExecute(r ApiGetCrossStagePolicyViolationByIdRequest) (*ApiCrossStageViolationDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiCrossStageViolationDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationsAPIService.GetCrossStagePolicyViolationById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/crossStage/{violationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"violationId"+"}", url.PathEscape(parameterValueToString(r.violationId, "violationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiCrossStageViolationDTOV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyViolationsRequest struct {
	ctx context.Context
	ApiService *PolicyViolationsAPIService
	p *[]string
	openTimeAfter *string
	openTimeBefore *string
}

func (r ApiGetPolicyViolationsRequest) P(p []string) ApiGetPolicyViolationsRequest {
	r.p = &p
	return r
}

func (r ApiGetPolicyViolationsRequest) OpenTimeAfter(openTimeAfter string) ApiGetPolicyViolationsRequest {
	r.openTimeAfter = &openTimeAfter
	return r
}

func (r ApiGetPolicyViolationsRequest) OpenTimeBefore(openTimeBefore string) ApiGetPolicyViolationsRequest {
	r.openTimeBefore = &openTimeBefore
	return r
}

func (r ApiGetPolicyViolationsRequest) Execute() (*ApiApplicationViolationListDTOV2, *http.Response, error) {
	return r.ApiService.GetPolicyViolationsExecute(r)
}

/*
GetPolicyViolations Method for GetPolicyViolations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPolicyViolationsRequest
*/
func (a *PolicyViolationsAPIService) GetPolicyViolations(ctx context.Context) ApiGetPolicyViolationsRequest {
	return ApiGetPolicyViolationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiApplicationViolationListDTOV2
func (a *PolicyViolationsAPIService) GetPolicyViolationsExecute(r ApiGetPolicyViolationsRequest) (*ApiApplicationViolationListDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApplicationViolationListDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationsAPIService.GetPolicyViolations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.p != nil {
		t := *r.p
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "p", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "p", t, "multi")
		}
	}
	if r.openTimeAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "openTimeAfter", r.openTimeAfter, "")
	}
	if r.openTimeBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "openTimeBefore", r.openTimeBefore, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiApplicationViolationListDTOV2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransitivePolicyViolationsByAppScanComponentRequest struct {
	ctx context.Context
	ApiService *PolicyViolationsAPIService
	ownerType string
	ownerId string
	scanId string
	componentIdentifier *ComponentIdentifier
	packageUrl *string
	hash *string
}

func (r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) ComponentIdentifier(componentIdentifier ComponentIdentifier) ApiGetTransitivePolicyViolationsByAppScanComponentRequest {
	r.componentIdentifier = &componentIdentifier
	return r
}

func (r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) PackageUrl(packageUrl string) ApiGetTransitivePolicyViolationsByAppScanComponentRequest {
	r.packageUrl = &packageUrl
	return r
}

func (r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) Hash(hash string) ApiGetTransitivePolicyViolationsByAppScanComponentRequest {
	r.hash = &hash
	return r
}

func (r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) Execute() (*ApiComponentTransitivePolicyViolationsDTO, *http.Response, error) {
	return r.ApiService.GetTransitivePolicyViolationsByAppScanComponentExecute(r)
}

/*
GetTransitivePolicyViolationsByAppScanComponent Method for GetTransitivePolicyViolationsByAppScanComponent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType
 @param ownerId
 @param scanId
 @return ApiGetTransitivePolicyViolationsByAppScanComponentRequest
*/
func (a *PolicyViolationsAPIService) GetTransitivePolicyViolationsByAppScanComponent(ctx context.Context, ownerType string, ownerId string, scanId string) ApiGetTransitivePolicyViolationsByAppScanComponentRequest {
	return ApiGetTransitivePolicyViolationsByAppScanComponentRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		scanId: scanId,
	}
}

// Execute executes the request
//  @return ApiComponentTransitivePolicyViolationsDTO
func (a *PolicyViolationsAPIService) GetTransitivePolicyViolationsByAppScanComponentExecute(r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) (*ApiComponentTransitivePolicyViolationsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiComponentTransitivePolicyViolationsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationsAPIService.GetTransitivePolicyViolationsByAppScanComponent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/transitive/{ownerType}/{ownerId}/{scanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scanId"+"}", url.PathEscape(parameterValueToString(r.scanId, "scanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.componentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentIdentifier", r.componentIdentifier, "")
	}
	if r.packageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageUrl", r.packageUrl, "")
	}
	if r.hash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash", r.hash, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiComponentTransitivePolicyViolationsDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest struct {
	ctx context.Context
	ApiService *PolicyViolationsAPIService
	ownerType string
	ownerId string
	stageId string
	componentIdentifier *ComponentIdentifier
	packageUrl *string
	hash *string
}

func (r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) ComponentIdentifier(componentIdentifier ComponentIdentifier) ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.componentIdentifier = &componentIdentifier
	return r
}

func (r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) PackageUrl(packageUrl string) ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.packageUrl = &packageUrl
	return r
}

func (r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) Hash(hash string) ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.hash = &hash
	return r
}

func (r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) Execute() (*ApiComponentTransitivePolicyViolationsDTO, *http.Response, error) {
	return r.ApiService.GetTransitivePolicyViolationsByOwnerStageComponentExecute(r)
}

/*
GetTransitivePolicyViolationsByOwnerStageComponent Method for GetTransitivePolicyViolationsByOwnerStageComponent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType
 @param ownerId
 @param stageId
 @return ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest
*/
func (a *PolicyViolationsAPIService) GetTransitivePolicyViolationsByOwnerStageComponent(ctx context.Context, ownerType string, ownerId string, stageId string) ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest {
	return ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		stageId: stageId,
	}
}

// Execute executes the request
//  @return ApiComponentTransitivePolicyViolationsDTO
func (a *PolicyViolationsAPIService) GetTransitivePolicyViolationsByOwnerStageComponentExecute(r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) (*ApiComponentTransitivePolicyViolationsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiComponentTransitivePolicyViolationsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationsAPIService.GetTransitivePolicyViolationsByOwnerStageComponent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/transitive/{ownerType}/{ownerId}/stages/{stageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stageId"+"}", url.PathEscape(parameterValueToString(r.stageId, "stageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.componentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentIdentifier", r.componentIdentifier, "")
	}
	if r.packageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageUrl", r.packageUrl, "")
	}
	if r.hash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash", r.hash, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiComponentTransitivePolicyViolationsDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
